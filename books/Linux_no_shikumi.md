# [試して理解] Linuxの仕組み ～実験と図解で学ぶOSとハードウェアの基礎知識
武内 覚. 技術評論社, 2018.03.08

Finish reading at:

###### Purpose
To learn the basics and fundamentals of Linus OS in order to introduce Arch Linux to my VAIO laptop.

## Notes
https://github.com/satoru-takeuchi/linux-in-practice/

### 第1章 コンピュータシステムの概要
- ユーザーモード: プロセス
- カーネルモード: デバイスドライバ->デバイス，プロセス管理システム，プロセススケジューラ，メモリ管理システム

カーネルモードで動作する(OSの核となる)処理をまとめたプログラム -> カーネル

プロセスはシステムコールを介してカーネルにカーネルの機能を依頼

### 第2章 ユーザーモードで実現する機能
#### システムコール
システムコール: カーネルへの処理の依頼
- プロセス生成，削除
- メモリ確保，解放
- プロセス間通信
- ネットワーク
- ファイルシステム操作
- ファイル操作(デバイスアクセス)

`strace -o hoge.log python3 ./code.py`でシステムコールを確認することができる

`sar -P ALL 1`: 1秒ごとに各CPUコアの処理を見る
- `%user`, `%nice`: ユーザーモードの処理(各プロセスの違いは4章)
- `%system`: カーネルモードでシステムコールなどの処理
- `%idle`: アイドル状態(詳しくは4章)

`sar -P ALL 1 1`: 情報を取得する回数を第4引数に追加

`%system`が数十程度なら，むやみなシステムコールを発行していたり，システムの付加が高いなど良くない状態であることが多い

`strace -T -o hello.log ./hello`: helloプログラムに対してどのシステムコールに時間がかかっているか分かる
(`-tt`オプションでm秒表示)

#### システムコールのラッパー関数
ラッパー関数: OSにある，内部的にシステムコールを呼び出す関数．
各高級言語(e.g. C言語)はラッパー関数を呼び出すだけでよくなる．
さもなくば，各プログラムがシステムコールのたびにアセンブリ言語(アーキテクチャ依存)を書かなければならない．

#### 標準Cライブラリ
glibc: GNUプロジェクトによる標準Cライブラリ(ISOによって定められたC言語の標準ライブラリに準している)．
通常はLinuxも含めこのライブラリが用いられる．
システムコールのラッパー関数を含む．
また，POSIX(UNIX系OSが備えているべき各種機能を定めた規格)に定義されている関数も提供．

`ldd`によってプログラムがどのようなライブラリをリンクしているか見る
- `ldd /bin/echo`: echoコマンド，書籍ではlibcがリンクされていた．

例えばPython3もlibcがリンクされており，`python3`コマンド自身は内部的には標準Cライブラリを用いている．
C言語は現在もOSレベルでは重要な言語

#### OSが提供するプログラム
OSの提供するプログラム(一例)
- touch, sysctl, grep, gcc, python, bash, ect

### 第3章 プロセス管理
仮想記憶がない単純な場合の説明．実際のプロセスの生成，削除の仕組みは第5章で．

#### 2段階のプロセス生成
Linuxにおけるプロセス生成の目的
- 同じプログラムの処理を複数のプロセスに分けて処理する(e.g. Webサーバーによる複数リクエストの受付)`fork()`(システムコール`clone()`)
- 全く別のプログラムを生成する(e.g. bashから各種プログラムの新規生成)`execve()`(システムコール`execve()`)

#### fork()関数
fork()関数の発行で，発行したプロセス(親プロセス)をもとに，新たにプロセス(子プロセス)を1つ生成する．

プロセスの新規生成プロセスは以下の通り
1. 子プロセス用メモリ領域を作成して，親プロセスのメモリをコピー
2. 親プロセスと子プロセスが違うコードを実行するように分岐(fork()関数の戻り値が親プロセスと子プロセスで異なることを利用)

fork()関数の戻り値
- 親プロセスなら，子プロセスのプロセスID
- 子プロセスなら，0

#### execve()関数
カーネルがそれぞれのプロセスを実行するまでの流れ
1. 実行ファイルを読みだして，プロセスのメモリマップに必要な情報を読みだす
2. 現在のプロセスのメモリを新しいプロセスのデータで上書き
3. 新しいプロセスの最初の命令から実行開始する

実行ファイルはプロセス実行中に用いるコードとデータ以外にも，実行開始に必要なデータも保持している
- コードを含むデータ領域のファイル上オフセット(基準からの距離)，サイズ，およびメモリマップ開始アドレス
- コード以外の変数などデータ領域についての上記と同じ情報
- 最初に実行する命令のメモリアドレス(エントリポイント)

Linuxの実行ファイルでは，Eexecutable Linkable Format(ELF)を用いる．
ELFの各種情報は`readelf`コマンドで得られる．
- `readelf -h /bin/sleep`: /bin/sleepの開始アドレスを得る
- `-S`オプションで，コードとデータのファイル内オフセット，サイズ，開始アドレスを得る

`cat /proc/{pid}/maps`でプログラム実行時に作成されたプロセスのメモリマップを得られる
- e.g. sleepコマンド: `/bin/sleep 10000 &` -> `cat /proc/{pid}/maps`

全く別のプロセスを新規生成する際には，親プロセスからfork()を発行して，復帰後に子プロセスがexec()を呼ぶことが多い(fork and exec)
- e.g. bashのプロセスが，echoのプロセスを生成

Pythonでは，`os.exec()`関数を経由してexecve()システムコールを読みだす

#### 終了処理
_exit()関数(システムコールexit_group())を使用してプログラムを終了．
プロセスに割り当てていたメモリをすべて回収．
